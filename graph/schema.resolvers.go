package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.73

import (
	"context"
	"errors"
	"fmt"
	"strconv"
	"sync"

	"github.com/AntonCkya/ozon_habr/graph/model"
	"github.com/AntonCkya/ozon_habr/internal/auth"
)

// CreatePost is the resolver for the createPost field.
func (r *mutationResolver) CreatePost(ctx context.Context, input model.PostInput) (*model.Post, error) {
	userID, ok := auth.GetUserID(ctx)
	if !ok {
		return nil, errors.New("invalid user")
	}

	if len(input.Title) == 0 || len(input.Content) == 0 {
		return nil, fmt.Errorf("title and content are required")
	}

	post, err := r.PostRepo.CreatePost(
		ctx,
		input.Title,
		input.Content,
		userID,
		input.Commentable,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to create post: %w", err)
	}

	fmt.Printf("User %d created post %d\n", userID, post.ID)

	user, err := r.UserRepo.GetUserByID(ctx, userID)
	if err != nil {
		return nil, fmt.Errorf("failed to get user: %w", err)
	}

	model_user := model.User{
		ID:       strconv.Itoa(userID),
		Username: user.Username,
	}

	model_post := model.Post{
		ID:          strconv.Itoa(post.ID),
		Title:       post.Title,
		Content:     post.Content,
		User:        &model_user,
		Commentable: post.Commentable,
		Comments:    []*model.Comment{},
	}

	return &model_post, nil
}

// UpdatePost is the resolver for the updatePost field.
func (r *mutationResolver) UpdatePost(ctx context.Context, id string, input model.PostInput) (*model.Post, error) {
	userID, ok := auth.GetUserID(ctx)
	if !ok {
		return nil, errors.New("invalid user")
	}

	if len(input.Title) == 0 || len(input.Content) == 0 {
		return nil, fmt.Errorf("title and content are required")
	}

	post_id, err := strconv.Atoi(id)
	if err != nil {
		return nil, fmt.Errorf("failed to convert post id to int: %w", err)
	}

	prev_post, err := r.PostRepo.GetPostByID(ctx, post_id)
	if err != nil {
		return nil, fmt.Errorf("failed to get post: %w", err)
	}
	if prev_post.UserID != userID {
		return nil, fmt.Errorf("failed to update post, check permission")
	}

	post, err := r.PostRepo.UpdatePost(
		ctx,
		post_id,
		input.Title,
		input.Content,
		userID,
		input.Commentable,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to update post: %w", err)
	}

	fmt.Printf("User %d updated post %d\n", userID, post.ID)

	user, err := r.UserRepo.GetUserByID(ctx, userID)
	if err != nil {
		return nil, fmt.Errorf("failed to get user: %w", err)
	}

	model_user := model.User{
		ID:       strconv.Itoa(userID),
		Username: user.Username,
	}

	comments, err := r.CommentRepo.GetCommentsByPostID(
		ctx,
		post.ID,
		10,
		0,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to get comments: %w", err)
	}

	var commentUsersIds []int
	for _, comment := range comments {
		commentUsersIds = append(commentUsersIds, comment.UserID)
	}
	comment_users, err := r.UserRepo.GetUsersByIDs(ctx, commentUsersIds)
	if err != nil {
		return nil, fmt.Errorf("failed to get users: %w", err)
	}

	var model_comments []*model.Comment
	for _, comment := range comments {
		currUserId := comment.UserID
		var username string
		for _, user := range comment_users {
			if user.ID == currUserId {
				username = user.Username
			}
		}
		var ParentId *string
		if comment.ParentID == nil {
			ParentId = nil
		} else {
			parentIdValue := strconv.Itoa(*comment.ParentID)
			ParentId = &parentIdValue
		}
		model_comments = append(model_comments, &model.Comment{
			ID:      strconv.Itoa(comment.ID),
			Content: comment.Content,
			User: &model.User{
				ID:       strconv.Itoa(currUserId),
				Username: username,
			},
			ParentID: ParentId,
			PostID:   strconv.Itoa(comment.PostID),
		})
	}

	model_post := model.Post{
		ID:          strconv.Itoa(post.ID),
		Title:       post.Title,
		Content:     post.Content,
		User:        &model_user,
		Commentable: post.Commentable,
		Comments:    model_comments,
	}

	return &model_post, nil
}

// DeletePost is the resolver for the deletePost field.
func (r *mutationResolver) DeletePost(ctx context.Context, id string) (bool, error) {
	userID, ok := auth.GetUserID(ctx)
	if !ok {
		return false, errors.New("invalid user")
	}

	post_id, err := strconv.Atoi(id)
	if err != nil {
		return false, fmt.Errorf("failed to convert post id to int: %w", err)
	}

	prev_post, err := r.PostRepo.GetPostByID(ctx, post_id)
	if err != nil {
		return false, fmt.Errorf("failed to get post: %w", err)
	}
	if prev_post.UserID != userID {
		return false, fmt.Errorf("failed to delete post, check permission")
	}

	err = r.PostRepo.DeletePost(
		ctx,
		post_id,
	)
	if err != nil {
		return false, fmt.Errorf("failed to delete post: %w", err)
	}

	fmt.Printf("User %d deleted post %d\n", userID, post_id)

	return true, nil
}

// CreateComment is the resolver for the createComment field.
func (r *mutationResolver) CreateComment(ctx context.Context, input model.CommentInput) (*model.Comment, error) {
	userID, ok := auth.GetUserID(ctx)
	if !ok {
		return nil, errors.New("invalid user")
	}

	if len(input.Content) == 0 {
		return nil, fmt.Errorf("content is required")
	}
	var err error

	var ParentId int
	if input.ParentID == nil {
		ParentId = -1
	} else {
		ParentId, err = strconv.Atoi(*input.ParentID)
		if err != nil {
			return nil, fmt.Errorf("failed to get parent comment: %w", err)
		}
	}

	PostId, err := strconv.Atoi(input.PostID)
	if err != nil {
		return nil, fmt.Errorf("failed to get post: %w", err)
	}

	post, err := r.PostRepo.GetPostByID(ctx, PostId)
	if err != nil {
		return nil, fmt.Errorf("failed to get post: %w", err)
	}
	if !post.Commentable {
		return nil, fmt.Errorf("failed to comment unommentable post")
	}

	comment, err := r.CommentRepo.CreateComment(
		ctx,
		input.Content,
		userID,
		PostId,
		ParentId,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to create comment: %w", err)
	}

	fmt.Printf("User %d commented post %d with comment %d\n", userID, PostId, comment.ID)

	user, err := r.UserRepo.GetUserByID(ctx, userID)
	if err != nil {
		return nil, fmt.Errorf("failed to get user: %w", err)
	}

	model_user := model.User{
		ID:       strconv.Itoa(userID),
		Username: user.Username,
	}

	model_comment := model.Comment{
		ID:       strconv.Itoa(comment.ID),
		Content:  comment.Content,
		User:     &model_user,
		ParentID: input.ParentID,
		PostID:   strconv.Itoa(comment.PostID),
	}

	for id, observer := range commentChannel {
		if id == input.PostID {
			observer <- &model_comment
		}
	}

	return &model_comment, nil
}

// UpdateComment is the resolver for the updateComment field.
func (r *mutationResolver) UpdateComment(ctx context.Context, id string, content string) (*model.Comment, error) {
	userID, ok := auth.GetUserID(ctx)
	if !ok {
		return nil, errors.New("invalid user")
	}

	if len(content) == 0 {
		return nil, fmt.Errorf("content is required")
	}

	commentId, err := strconv.Atoi(id)
	if err != nil {
		return nil, fmt.Errorf("failed to get comment: %w", err)
	}

	prev_comment, err := r.CommentRepo.GetCommentByID(
		ctx,
		commentId,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to get comment: %w", err)
	}
	if prev_comment.UserID != userID {
		return nil, fmt.Errorf("failed to update comment, check permission")
	}

	comment, err := r.CommentRepo.UpdateComment(
		ctx,
		commentId,
		content,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to update comment: %w", err)
	}

	fmt.Printf("User %d update comment %d\n", userID, comment.ID)

	user, err := r.UserRepo.GetUserByID(ctx, userID)
	if err != nil {
		return nil, fmt.Errorf("failed to get user: %w", err)
	}

	model_user := model.User{
		ID:       strconv.Itoa(userID),
		Username: user.Username,
	}

	var ParentId *string
	if comment.ParentID == nil {
		ParentId = nil
	} else {
		parentIdValue := strconv.Itoa(*comment.ParentID)
		ParentId = &parentIdValue
	}

	model_comment := model.Comment{
		ID:       strconv.Itoa(comment.ID),
		Content:  comment.Content,
		User:     &model_user,
		ParentID: ParentId,
		PostID:   strconv.Itoa(comment.PostID),
	}

	return &model_comment, nil
}

// DeleteComment is the resolver for the deleteComment field.
func (r *mutationResolver) DeleteComment(ctx context.Context, id string) (bool, error) {
	userID, ok := auth.GetUserID(ctx)
	if !ok {
		return false, errors.New("invalid user")
	}

	commentId, err := strconv.Atoi(id)
	if err != nil {
		return false, fmt.Errorf("failed to get comment: %w", err)
	}

	prev_comment, err := r.CommentRepo.GetCommentByID(
		ctx,
		commentId,
	)
	if err != nil {
		return false, fmt.Errorf("failed to get comment: %w", err)
	}
	if prev_comment.UserID != userID {
		return false, fmt.Errorf("failed to update comment, check permission")
	}

	err = r.CommentRepo.DeleteComment(
		ctx,
		commentId,
	)
	if err != nil {
		return false, fmt.Errorf("failed to delete comment: %w", err)
	}

	fmt.Printf("User %d deleted comment %d\n", userID, commentId)

	return true, nil
}

// Posts is the resolver for the posts field.
func (r *queryResolver) Posts(ctx context.Context, limit *int32, offset *int32) ([]*model.Post, error) {
	userID, ok := auth.GetUserID(ctx)
	if !ok {
		return nil, errors.New("invalid user")
	}

	fmt.Printf("User %d finding posts, limit %d, offset %d\n", userID, limit, offset)

	posts, err := r.PostRepo.GetPosts(ctx, int(*limit), int(*offset))
	if err != nil {
		return nil, fmt.Errorf("failed to get posts: %w", err)
	}
	var userIds []int
	var postIds []int
	for _, post := range posts {
		userIds = append(userIds, post.UserID)
		postIds = append(postIds, post.ID)
	}
	users, err := r.UserRepo.GetUsersByIDs(ctx, userIds)
	if err != nil {
		return nil, fmt.Errorf("failed to get users: %w", err)
	}

	comments, err := r.CommentRepo.GetCommentsByPostIDs(ctx, postIds)
	if err != nil {
		return nil, fmt.Errorf("failed to get comments: %w", err)
	}

	var commentUsersIds []int
	for _, comment := range comments {
		commentUsersIds = append(commentUsersIds, comment.UserID)
	}
	comment_users, err := r.UserRepo.GetUsersByIDs(ctx, commentUsersIds)
	if err != nil {
		return nil, fmt.Errorf("failed to get users: %w", err)
	}

	var model_posts []*model.Post
	for i := 0; i < len(posts); i++ {
		currUserId := posts[i].UserID
		var username string
		for _, user := range users {
			if user.ID == currUserId {
				username = user.Username
			}
		}

		var model_comments []*model.Comment
		for _, comment := range comments {
			if comment.PostID != posts[i].ID {
				continue
			}
			currUserCommentId := comment.UserID
			var username string
			for _, user := range comment_users {
				if user.ID == currUserCommentId {
					username = user.Username
				}
			}
			var ParentId *string
			if comment.ParentID == nil {
				ParentId = nil
			} else {
				parentIdValue := strconv.Itoa(*comment.ParentID)
				ParentId = &parentIdValue
			}
			model_comments = append(model_comments, &model.Comment{
				ID:      strconv.Itoa(comment.ID),
				Content: comment.Content,
				User: &model.User{
					ID:       strconv.Itoa(currUserCommentId),
					Username: username,
				},
				ParentID: ParentId,
				PostID:   strconv.Itoa(comment.PostID),
			})
		}

		model_posts = append(model_posts, &model.Post{
			ID:      strconv.Itoa(posts[i].ID),
			Title:   posts[i].Title,
			Content: posts[i].Content,
			User: &model.User{
				ID:       strconv.Itoa(currUserId),
				Username: username,
			},
			Commentable: posts[i].Commentable,
			Comments:    model_comments,
		})
	}

	return model_posts, nil
}

// PostsByUser is the resolver for the postsByUser field.
func (r *queryResolver) PostsByUser(ctx context.Context, limit *int32, offset *int32, userID string) ([]*model.Post, error) {
	queryUserID, ok := auth.GetUserID(ctx)
	if !ok {
		return nil, errors.New("invalid user")
	}

	fmt.Printf("User %d finding posts\n", queryUserID)

	dbUserId, err := strconv.Atoi(userID)
	if err != nil {
		return nil, fmt.Errorf("failed to get user: %w", err)
	}

	posts, err := r.PostRepo.GetPostsByUserId(ctx, int(*limit), int(*offset), dbUserId)
	if err != nil {
		return nil, fmt.Errorf("failed to get posts: %w", err)
	}
	var userIds []int
	var postIds []int
	for _, post := range posts {
		userIds = append(userIds, post.UserID)
		postIds = append(postIds, post.ID)
	}
	users, err := r.UserRepo.GetUsersByIDs(ctx, userIds)
	if err != nil {
		return nil, fmt.Errorf("failed to get users: %w", err)
	}

	comments, err := r.CommentRepo.GetCommentsByPostIDs(ctx, postIds)
	if err != nil {
		return nil, fmt.Errorf("failed to get comments: %w", err)
	}

	var commentUsersIds []int
	for _, comment := range comments {
		commentUsersIds = append(commentUsersIds, comment.UserID)
	}
	comment_users, err := r.UserRepo.GetUsersByIDs(ctx, commentUsersIds)
	if err != nil {
		return nil, fmt.Errorf("failed to get users: %w", err)
	}

	var model_posts []*model.Post
	for i := 0; i < len(posts); i++ {
		currUserId := posts[i].UserID
		var username string
		for _, user := range users {
			if user.ID == currUserId {
				username = user.Username
			}
		}

		var model_comments []*model.Comment
		for _, comment := range comments {
			if comment.PostID != posts[i].ID {
				continue
			}
			currUserCommentId := comment.UserID
			var username string
			for _, user := range comment_users {
				if user.ID == currUserCommentId {
					username = user.Username
				}
			}
			var ParentId *string
			if comment.ParentID == nil {
				ParentId = nil
			} else {
				parentIdValue := strconv.Itoa(*comment.ParentID)
				ParentId = &parentIdValue
			}
			model_comments = append(model_comments, &model.Comment{
				ID:      strconv.Itoa(comment.ID),
				Content: comment.Content,
				User: &model.User{
					ID:       strconv.Itoa(currUserCommentId),
					Username: username,
				},
				ParentID: ParentId,
				PostID:   strconv.Itoa(comment.PostID),
			})
		}

		model_posts = append(model_posts, &model.Post{
			ID:      strconv.Itoa(posts[i].ID),
			Title:   posts[i].Title,
			Content: posts[i].Content,
			User: &model.User{
				ID:       strconv.Itoa(currUserId),
				Username: username,
			},
			Commentable: posts[i].Commentable,
			Comments:    model_comments,
		})
	}

	return model_posts, nil
}

// Post is the resolver for the post field.
func (r *queryResolver) Post(ctx context.Context, id string) (*model.Post, error) {
	userID, ok := auth.GetUserID(ctx)
	if !ok {
		return nil, errors.New("invalid user")
	}

	post_id, err := strconv.Atoi(id)
	if err != nil {
		return nil, fmt.Errorf("failed to convert post id to int: %w", err)
	}

	fmt.Printf("User %d finding post %d\n", userID, post_id)

	post, err := r.PostRepo.GetPostByID(ctx, post_id)
	if err != nil {
		return nil, fmt.Errorf("failed to get post: %w", err)
	}

	user, err := r.UserRepo.GetUserByID(ctx, userID)
	if err != nil {
		return nil, fmt.Errorf("failed to get user: %w", err)
	}

	model_user := model.User{
		ID:       strconv.Itoa(userID),
		Username: user.Username,
	}

	comments, err := r.CommentRepo.GetCommentsByPostID(
		ctx,
		post.ID,
		10,
		0,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to get comments: %w", err)
	}

	var commentUsersIds []int
	for _, comment := range comments {
		commentUsersIds = append(commentUsersIds, comment.UserID)
	}
	comment_users, err := r.UserRepo.GetUsersByIDs(ctx, commentUsersIds)
	if err != nil {
		return nil, fmt.Errorf("failed to get users: %w", err)
	}

	var model_comments []*model.Comment
	for _, comment := range comments {
		currUserId := comment.UserID
		var username string
		for _, user := range comment_users {
			if user.ID == currUserId {
				username = user.Username
			}
		}
		var ParentId *string
		if comment.ParentID == nil {
			ParentId = nil
		} else {
			parentIdValue := strconv.Itoa(*comment.ParentID)
			ParentId = &parentIdValue
		}
		model_comments = append(model_comments, &model.Comment{
			ID:      strconv.Itoa(comment.ID),
			Content: comment.Content,
			User: &model.User{
				ID:       strconv.Itoa(currUserId),
				Username: username,
			},
			ParentID: ParentId,
			PostID:   strconv.Itoa(comment.PostID),
		})
	}

	model_post := model.Post{
		ID:          strconv.Itoa(post.ID),
		Title:       post.Title,
		Content:     post.Content,
		User:        &model_user,
		Commentable: post.Commentable,
		Comments:    model_comments,
	}

	return &model_post, nil
}

// Comments is the resolver for the comments field.
func (r *queryResolver) Comments(ctx context.Context, limit *int32, offset *int32, postID string) ([]*model.Comment, error) {
	userID, ok := auth.GetUserID(ctx)
	if !ok {
		return nil, errors.New("invalid user")
	}

	post_id, err := strconv.Atoi(postID)
	if err != nil {
		return nil, fmt.Errorf("failed to convert post id to int: %w", err)
	}

	fmt.Printf("User %d finding commens on post %d\n", userID, post_id)

	comments, err := r.CommentRepo.GetCommentsByPostID(
		ctx,
		post_id,
		int(*limit),
		int(*offset),
	)
	if err != nil {
		return nil, fmt.Errorf("failed to get comments: %w", err)
	}

	var commentUsersIds []int
	for _, comment := range comments {
		commentUsersIds = append(commentUsersIds, comment.UserID)
	}
	comment_users, err := r.UserRepo.GetUsersByIDs(ctx, commentUsersIds)
	if err != nil {
		return nil, fmt.Errorf("failed to get users: %w", err)
	}

	var model_comments []*model.Comment
	for _, comment := range comments {
		currUserId := comment.UserID
		var username string
		for _, user := range comment_users {
			if user.ID == currUserId {
				username = user.Username
			}
		}
		var ParentId *string
		if comment.ParentID == nil {
			ParentId = nil
		} else {
			parentIdValue := strconv.Itoa(*comment.ParentID)
			ParentId = &parentIdValue
		}
		model_comments = append(model_comments, &model.Comment{
			ID:      strconv.Itoa(comment.ID),
			Content: comment.Content,
			User: &model.User{
				ID:       strconv.Itoa(currUserId),
				Username: username,
			},
			ParentID: ParentId,
			PostID:   strconv.Itoa(comment.PostID),
		})
	}

	return model_comments, nil
}

var commentChannel map[string]chan *model.Comment
var commentChannelMu sync.Mutex

func init() {
	commentChannel = map[string]chan *model.Comment{}
}

// NewComments is the resolver for the newComments field.
func (r *subscriptionResolver) NewComments(ctx context.Context, postID string) (<-chan *model.Comment, error) {
	userID, ok := auth.GetUserID(ctx)
	if !ok {
		return nil, errors.New("invalid user")
	}
	fmt.Printf("User %d subscribe to comments on post %s", userID, postID)
	defer fmt.Printf("Subscribe to post %s by user %d ended", postID, userID)

	commentChannelMu.Lock()
	defer commentChannelMu.Unlock()

	if ch, ok := commentChannel[postID]; ok {
		return ch, nil
	}

	event := make(chan *model.Comment, 1)
	go func() {
		<-ctx.Done()
		commentChannelMu.Lock()
		defer commentChannelMu.Unlock()
		close(event)
		delete(commentChannel, postID)
	}()
	commentChannel[postID] = event
	return event, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
